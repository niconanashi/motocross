"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var fs = require("fs");
var fsx = require("fs-extra");
var js_sha256_1 = require("js-sha256");
exports.ERROR_FILENAME_CONFLICT = "ERROR_FILENAME_CONFLICT";
exports.ERROR_PATH_INCLUDE_ANCESTOR = "ERROR_PATH_INCLUDE_ANCESTOR";
/**
 * 与えられたファイルパスのファイル名部分を、ファイルパスから計算したハッシュ値で置き換え、 files/ 以下のファイルパスにして返す
 * @param filepath 変換するファイルパス
 * @param nameLength ファイル名の文字数の最大値
 */
function hashFilepath(filepath, nameLength) {
    var hashedFilename = js_sha256_1.sha256(filepath).slice(0, nameLength);
    var extname = path.extname(filepath);
    return path.posix.join("files", hashedFilename + extname);
}
exports.hashFilepath = hashFilepath;
/**
 * アセット・ globalScripts のファイル名をファイルパスに基づいてハッシュ化し、アセットファイル名をリネームする
 * @param content 読み込む game.json
 * @param basedir 読み込む gamejson が置かれているパス
 * @param maxHashLength ハッシュ化後のファイル名の文字数の最大値。省略された場合、20文字
 */
function renameAssetFilenames(content, basedir, maxHashLength) {
    if (maxHashLength === void 0) { maxHashLength = 20; }
    var processedAssetPaths = new Set();
    _renameAssets(content, basedir, maxHashLength, processedAssetPaths);
    _renameGlobalScripts(content, processedAssetPaths, basedir, maxHashLength);
}
exports.renameAssetFilenames = renameAssetFilenames;
/**
 * 指定されたファイルをリネームする
 * @param basedir リネームするファイルが置かれているパス
 * @param filePath リネームするファイルのパス
 * @param newFilePath リネームされたファイルのパス
 */
function _renameFilename(basedir, filePath, newFilePath, processedAssetPaths) {
    try {
        fs.accessSync(path.resolve(basedir, newFilePath));
    }
    catch (error) {
        if (error.code === "ENOENT") {
            fsx.mkdirsSync(path.dirname(path.resolve(basedir, newFilePath)));
            fs.renameSync(path.resolve(basedir, filePath), path.resolve(basedir, newFilePath));
            return;
        }
        throw error;
    }
    throw new Error(exports.ERROR_FILENAME_CONFLICT);
}
function _renameAudioFilename(basedir, filePath, newFilePath, processedAssetPaths) {
    var extTypes = [".ogg", ".aac", ".mp4"];
    extTypes.forEach(function (ext) {
        try {
            fs.accessSync(path.resolve(basedir, filePath + ext));
            _renameFilename(basedir, filePath + ext, newFilePath + ext, processedAssetPaths);
        }
        catch (error) {
            if (error.code === "ENOENT")
                return; // 全てのオーディオ拡張子が揃っているとは限らない
            throw error;
        }
    });
}
function _renameAssets(content, basedir, maxHashLength, processedAssetPaths) {
    var assetNames = Object.keys(content.assets);
    var dirpaths = [];
    assetNames.forEach(function (name) {
        var filePath = content.assets[name].path;
        dirpaths.push(path.dirname(filePath));
        var hashedFilePath = hashFilepath(filePath, maxHashLength);
        var isRenamedAsset = processedAssetPaths.has(hashedFilePath);
        content.assets[name].path = hashedFilePath;
        content.assets[name].virtualPath = filePath;
        processedAssetPaths.add(hashedFilePath);
        if (isRenamedAsset)
            return; // 同じパスのアセットを既にハッシュ化済みの場合、ファイルはリネーム済み
        if (content.assets[name].type !== "audio") {
            _renameFilename(basedir, filePath, hashedFilePath, processedAssetPaths);
        }
        else {
            _renameAudioFilename(basedir, filePath, hashedFilePath, processedAssetPaths);
        }
    });
    var assetAncestorDirs = _listAncestorDirNames(dirpaths);
    _removeDirectoryIfEmpty(assetAncestorDirs, basedir);
}
function _renameGlobalScripts(content, processedAssetPaths, basedir, maxHashLength) {
    if (content.globalScripts) {
        content.globalScripts.forEach(function (name, idx) {
            var assetname = "a_e_z_" + idx;
            var hashedFilePath = hashFilepath(name, maxHashLength);
            var isRenamedAsset = processedAssetPaths.has(hashedFilePath);
            content.assets[assetname] = {
                type: /\.json$/i.test(name) ? "text" : "script",
                virtualPath: name,
                path: hashedFilePath,
                global: true
            };
            processedAssetPaths.add(hashedFilePath);
            if (isRenamedAsset)
                return; // 同じパスのアセットを既にハッシュ化済みの場合、ファイルはリネーム済み
            _renameFilename(basedir, name, hashedFilePath, processedAssetPaths);
        });
        var assetDirs = _listAncestorDirNames(content.globalScripts.map(function (filepath) { return path.dirname(filepath); }));
        _removeDirectoryIfEmpty(assetDirs, basedir);
    }
    content.globalScripts = [];
}
function _removeDirectoryIfEmpty(dirpaths, basedir) {
    // パス文字列長でソートすることで、空ディレクトリしかないツリーでも末端から削除できるようにする
    dirpaths.sort(function (a, b) { return (b.length - a.length); });
    dirpaths.forEach(function (dirpath) {
        var dirFullPath = path.resolve(basedir, dirpath);
        if (/^\.\./.test(path.relative(basedir, dirFullPath)))
            throw new Error(exports.ERROR_PATH_INCLUDE_ANCESTOR);
        try {
            fs.accessSync(dirFullPath);
            fs.rmdirSync(dirFullPath);
        }
        catch (error) {
            if (["ENOENT", "EEXIST", "ENOTEMPTY"].indexOf(error.code) !== -1)
                return;
            throw error;
        }
    });
}
exports._removeDirectoryIfEmpty = _removeDirectoryIfEmpty;
/**
 * ディレクトリの相対パスを受け取り、そのパス内で表現されているもっとも祖先にあたるディレクトリまでの各祖先ディレクトリをリストで返す
 */
function _listAncestorDirNames(dirpaths) {
    var result = new Set();
    dirpaths.forEach(function (dirpath) {
        var currentDir = path.normalize(dirpath);
        while (currentDir.indexOf(path.sep) !== -1) {
            result.add(currentDir);
            currentDir = path.dirname(currentDir);
        }
        // path.normalizeによって `./` が消えるためwhile中で拾えないrootパスをaddする
        if (currentDir !== "..")
            result.add(currentDir);
    });
    return Array.from(new Set(result));
}
exports._listAncestorDirNames = _listAncestorDirNames;
