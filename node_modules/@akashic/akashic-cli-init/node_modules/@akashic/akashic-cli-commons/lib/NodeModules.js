"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var browserify = require("browserify");
var Util = require("./Util");
var ConsoleLogger_1 = require("./ConsoleLogger");
var StringStream_1 = require("./StringStream");
var NodeModules;
(function (NodeModules) {
    function listModuleFiles(basepath, modules, logger) {
        if (logger === void 0) { logger = new ConsoleLogger_1.ConsoleLogger(); }
        if (modules.length === 0)
            return Promise.resolve([]);
        return Promise.resolve()
            .then(function () { return NodeModules.listScriptFiles(basepath, modules, logger); })
            .then(function (paths) { return paths.concat(NodeModules.listPackageJsonsFromScriptsPath(basepath, paths)); });
    }
    NodeModules.listModuleFiles = listModuleFiles;
    function listPackageJsonsFromScriptsPath(basepath, filepaths) {
        var packageJsonPaths = [];
        var alreadyProcessed = {};
        filepaths.forEach(function (filepath) {
            var m = /(.*node_modules\/(?:@.*?\/)?(?:.*?)\/)/.exec(filepath);
            if (!m)
                return;
            var dirPath = m[1];
            if (alreadyProcessed[dirPath])
                return;
            alreadyProcessed[dirPath] = true;
            var packageJsonPath = Util.makeUnixPath(path.join(basepath, dirPath, "package.json"));
            try {
                if (!fs.lstatSync(packageJsonPath).isFile())
                    return;
                packageJsonPaths.push(Util.makeUnixPath(path.relative(basepath, packageJsonPath)));
            }
            catch (e) { }
        });
        return packageJsonPaths;
    }
    NodeModules.listPackageJsonsFromScriptsPath = listPackageJsonsFromScriptsPath;
    function listModuleMainScripts(packageJsonFiles) {
        if (packageJsonFiles.length === 0)
            return {};
        var moduleMainScripts = {};
        for (var i = 0; i < packageJsonFiles.length; i++) {
            var packageJsonFile = packageJsonFiles[i];
            var packageJsonData = fs.readFileSync(packageJsonFile, "utf-8");
            var mainScript;
            var moduleName;
            try {
                var d = JSON.parse(packageJsonData);
                mainScript = path.join(path.dirname(packageJsonFile), d.main);
                moduleName = d.name;
            }
            catch (e) {
                // do nothing
            }
            if (moduleName && moduleName !== "" && mainScript && mainScript !== "") {
                moduleMainScripts[moduleName] = Util.makeUnixPath(mainScript);
            }
        }
        return moduleMainScripts;
    }
    NodeModules.listModuleMainScripts = listModuleMainScripts;
    function listScriptFiles(basepath, modules, logger) {
        if (modules.length === 0)
            return Promise.resolve([]);
        var moduleNames = (typeof modules === "string") ? [modules] : modules;
        // moduleNamesをrequireするだけのソースコード文字列を作って依存性解析の基点にする
        // (moduleNamesを直接b.require()してもよいはずだが、そうするとモジュールのエントリポイントの代わりに
        // モジュールの名前(ディレクトリ名であることが多い)が出力されてしまうので避ける)
        var dummyRootName = path.join(basepath, "__akashic-cli_dummy_require_root.js");
        var rootRequirer = moduleNames.map(function (name) {
            return "require(\"" + Util.makeModuleNameNoVer(name) + "\");";
        }).join("\n");
        // akashicコンテンツが Node.js のコアモジュールを参照するモジュールに依存している場合、
        // akashic-cli-commons/node_modules 以下への依存として表現される。
        // これを検知した場合、そのモジュールへの依存はgame.jsonに追記せず、akashicコマンドユーザには警告を表示する。
        var ignoreModulePaths = ["/akashic-cli-commons/node_modules/"];
        var b = browserify({
            entries: new StringStream_1.StringStream(rootRequirer, dummyRootName),
            basedir: basepath,
            builtins: true // builtins (コアモジュール) はサポートしていないが、b.on("dep", ...) で検出するためにtrueにする
        });
        b.external("g");
        return new Promise(function (resolve, reject) {
            var filePaths = [];
            b.on("dep", function (row) {
                var filePath = Util.makeUnixPath(path.relative(basepath, row.file));
                if (!(/^(?:\.\/)?node_modules/.test(filePath))) {
                    return;
                }
                if (/^\.\.\//.test(filePath)) {
                    var rawFilePath_1 = Util.makeUnixPath(row.file);
                    if (ignoreModulePaths.find(function (modulePath) { return rawFilePath_1.includes(modulePath); })) {
                        var detectedModuleName = path.basename(path.dirname(filePath));
                        var msg_1 = "Reference to '" + detectedModuleName
                            + "' is detected and skipped listing."
                            + " Akashic content cannot depend on core modules of Node.js."
                            + " You should build your game runnable without '" + detectedModuleName + "'.";
                        logger.warn(msg_1);
                        return;
                    }
                    var msg = "Unsupported module found in " + JSON.stringify(modules)
                        + ". Skipped listing '" + filePath
                        + "' that cannot be dealt with. (This may be a core module of Node.js)";
                    reject(new Error(msg));
                    return;
                }
                filePaths.push(filePath);
            });
            b.bundle(function (err) {
                err ? reject(err) : resolve(filePaths);
            });
        });
    }
    NodeModules.listScriptFiles = listScriptFiles;
})(NodeModules = exports.NodeModules || (exports.NodeModules = {}));
