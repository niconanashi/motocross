"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var cmn = require("@akashic/akashic-cli-commons");
var convertNoBundle_1 = require("./convertNoBundle");
var convertBundle_1 = require("./convertBundle");
var fs = require("fs");
var fsx = require("fs-extra");
var path = require("path");
var os = require("os");
function _completeExportHTMLParameterObject(p) {
    var param = __assign({}, p);
    var source = param.source ? param.source : "./";
    param.source = path.resolve(param.cwd, source);
    param.output = param.output ? path.resolve(param.cwd, param.output) : undefined;
    param.logger = param.logger || new cmn.ConsoleLogger();
    return param;
}
exports._completeExportHTMLParameterObject = _completeExportHTMLParameterObject;
function promiseExportHTML(p) {
    var param = _completeExportHTMLParameterObject(p);
    var gamepath;
    param.logger.info("exporting content into html...");
    if (!param.strip && param.output != null && !/^\.\./.test(path.relative(param.source, param.output))) {
        param.logger.warn("The output path overlaps with the game directory: files will be exported into the game directory.");
        param.logger.warn("NOTE that after this, exporting this game with --no-strip option may include the files.");
    }
    return new Promise(function (resolve, reject) {
        if (!param.output) {
            param.output = fs.mkdtempSync(path.join(os.tmpdir(), "akashic-export-html-tmp-"));
            return resolve();
        }
        fs.stat(path.resolve(param.output), function (error, stat) {
            if (error) {
                if (error.code !== "ENOENT") {
                    return reject("Output directory has bad status. Error code " + error.code);
                }
                fs.mkdir(path.resolve(param.output), function (err) {
                    if (err) {
                        return reject("Create " + param.output + " directory failed.");
                    }
                    resolve();
                });
            }
            else if (stat) {
                if (!stat.isDirectory()) {
                    return reject(param.output + " is not directory.");
                }
                if (!param.force) {
                    return reject("The output directory " + param.output + " already exists. Cannot overwrite without force option.");
                }
                resolve();
            }
        });
    })
        .then(function () {
        if (param.hashLength === 0)
            return param.source;
        return createRenamedGame(param.source, param.hashLength, param.logger);
    })
        .then(function (currentGamepath) {
        gamepath = currentGamepath;
        var convertParam = {
            output: param.output,
            logger: param.logger,
            strip: param.strip,
            minify: param.minify,
            magnify: param.magnify,
            force: param.force,
            source: gamepath,
            cwd: param.cwd,
            injects: param.injects,
            unbundleText: param.unbundleText,
            lint: param.lint
        };
        if (param.bundle) {
            return convertBundle_1.promiseConvertBundle(convertParam);
        }
        else {
            return convertNoBundle_1.promiseConvertNoBundle(convertParam);
        }
    })
        .then(function () {
        // ハッシュ化した場合一時ファイルが生成されるため削除する
        if (param.hashLength > 0) {
            param.logger.info("removing temp files...");
            fsx.removeSync(gamepath);
        }
    })
        .catch(function (error) {
        param.logger.error(error);
        throw error;
    })
        .then(function () {
        param.logger.info("Done!");
        return param.output;
    });
}
exports.promiseExportHTML = promiseExportHTML;
function exportHTML(param, cb) {
    promiseExportHTML(param).then(cb).catch(cb);
}
exports.exportHTML = exportHTML;
function createRenamedGame(sourcePath, hashLength, logger) {
    var destDirPath = path.resolve(fs.mkdtempSync(path.join(os.tmpdir(), "akashic-export-html-")));
    fsx.copySync(sourcePath, destDirPath);
    return Promise.resolve()
        .then(function () { return cmn.ConfigurationFile.read(path.join(destDirPath, "game.json"), logger); })
        .then(function (gamejson) {
        cmn.Renamer.renameAssetFilenames(gamejson, destDirPath, hashLength);
        return cmn.ConfigurationFile.write(gamejson, path.resolve(path.join(destDirPath, "game.json")), logger);
    }).then(function () { return destDirPath; });
}
