"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var cmn = require("@akashic/akashic-cli-commons");
var fsx = require("fs-extra");
var ect = require("ect");
var convertUtil_1 = require("./convertUtil");
function promiseConvertNoBundle(options) {
    return __awaiter(this, void 0, void 0, function () {
        var content, conf, assetPaths, gamejsonPath, assetNames, errorMessages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, cmn.ConfigurationFile.read(path.join(options.source, "game.json"), options.logger)];
                case 1:
                    content = _a.sent();
                    if (!content.environment)
                        content.environment = {};
                    content.environment["sandbox-runtime"] = content.environment["sandbox-runtime"] ? content.environment["sandbox-runtime"] : "1";
                    conf = new cmn.Configuration({
                        content: content
                    });
                    assetPaths = [];
                    writeCommonFiles(options.source, options.output, conf, options);
                    gamejsonPath = path.resolve(options.output, "./js/game.json.js");
                    fsx.outputFileSync(gamejsonPath, wrapText(JSON.stringify(conf._content, null, "\t"), "game.json"));
                    assetPaths.push("./js/game.json.js");
                    assetNames = convertUtil_1.extractAssetDefinitions(conf, "script").concat(convertUtil_1.extractAssetDefinitions(conf, "text"));
                    errorMessages = [];
                    assetPaths = assetPaths.concat(assetNames.map(function (assetName) {
                        return convertAssetAndOutput(assetName, conf, options.source, options.output, options.minify, options.lint, errorMessages);
                    }));
                    if (conf._content.globalScripts) {
                        assetPaths = assetPaths.concat(conf._content.globalScripts.map(function (scriptName) {
                            return convertGlobalScriptAndOutput(scriptName, options.source, options.output, options.minify, options.lint, errorMessages);
                        }));
                    }
                    if (errorMessages.length > 0) {
                        options.logger.warn("The following ES5 syntax errors exist.\n" + errorMessages.join("\n"));
                    }
                    writeEct(assetPaths, options.output, conf, options);
                    writeOptionScript(options.output, options);
                    return [2 /*return*/];
            }
        });
    });
}
exports.promiseConvertNoBundle = promiseConvertNoBundle;
function convertAssetAndOutput(assetName, conf, inputPath, outputPath, minify, lint, errors) {
    var assets = conf._content.assets;
    var isScript = assets[assetName].type === "script";
    var assetString = fs.readFileSync(path.join(inputPath, assets[assetName].path), "utf8").replace(/\r\n|\r/g, "\n");
    var assetPath = assets[assetName].path;
    if (isScript && lint) {
        errors.push.apply(errors, convertUtil_1.validateEs5Code(assetPath, assetString)); // ES5構文に反する箇所があるかのチェック
    }
    var code = (isScript ? wrapScript(assetString, assetName, minify) : wrapText(assetString, assetName));
    var relativePath = "./js/assets/" + path.dirname(assetPath) + "/" +
        path.basename(assetPath, path.extname(assetPath)) + (isScript ? ".js" : ".json.js");
    var filePath = path.resolve(outputPath, relativePath);
    fsx.outputFileSync(filePath, code);
    return relativePath;
}
function convertGlobalScriptAndOutput(scriptName, inputPath, outputPath, minify, lint, errors) {
    var scriptString = fs.readFileSync(path.join(inputPath, scriptName), "utf8").replace(/\r\n|\r/g, "\n");
    var isScript = /\.js$/i.test(scriptName);
    if (isScript && lint) {
        errors.push.apply(errors, convertUtil_1.validateEs5Code(scriptName, scriptString)); // ES5構文に反する箇所があるかのチェック
    }
    var code = isScript ? wrapScript(scriptString, scriptName, minify) : wrapText(scriptString, scriptName);
    var relativePath = "./globalScripts/" + scriptName + (isScript ? "" : ".js");
    var filePath = path.resolve(outputPath, relativePath);
    fsx.outputFileSync(filePath, code);
    return relativePath;
}
function writeEct(assetPaths, outputPath, conf, options) {
    var injects = options.injects ? options.injects : [];
    var ectRender = ect({ root: __dirname + "/../templates-build", ext: ".ect" });
    var html = ectRender.render("no-bundle-index", {
        assets: assetPaths,
        magnify: !!options.magnify,
        injectedContents: convertUtil_1.getInjectedContents(options.cwd, injects)
    });
    fs.writeFileSync(path.resolve(outputPath, "./index.html"), html);
}
function writeCommonFiles(inputPath, outputPath, conf, options) {
    if (options.strip) {
        convertUtil_1.copyAssetFilesStrip(inputPath, outputPath, conf._content.assets, options);
    }
    else {
        convertUtil_1.copyAssetFiles(inputPath, outputPath, options);
    }
    var templatePath;
    switch (conf._content.environment["sandbox-runtime"]) {
        case "1":
            templatePath = "templates-build/v1";
            break;
        case "2":
            templatePath = "templates-build/v2";
            break;
        default:
            throw Error("Unknown engine version: `environment[\"sandbox-runtime\"]` field in game.json should be \"1\" or \"2\".");
    }
    fsx.copySync(path.resolve(__dirname, "..", templatePath), outputPath);
}
function writeOptionScript(outputPath, options) {
    var script = "\nif (! (\"optionProps\" in window)) {\n\twindow.optionProps = {};\n}\nwindow.optionProps.magnify = " + !!options.magnify + ";\n\t";
    fs.writeFileSync(path.resolve(outputPath, "./js/option.js"), script);
}
function wrapScript(code, name, minify) {
    return "window.gLocalAssetContainer[\"" + name + "\"] = function(g) { " + convertUtil_1.wrap(code, minify) + "}";
}
function wrapText(code, name) {
    var PRE_SCRIPT = "window.gLocalAssetContainer[\"" + name + "\"] = \"";
    var POST_SCRIPT = "\"";
    return PRE_SCRIPT + convertUtil_1.encodeText(code) + POST_SCRIPT + "\n";
}
