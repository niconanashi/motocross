"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var cmn = require("@akashic/akashic-cli-commons");
var fsx = require("fs-extra");
var ect = require("ect");
var convertUtil_1 = require("./convertUtil");
function promiseConvertBundle(options) {
    return __awaiter(this, void 0, void 0, function () {
        var content, conf, innerHTMLAssetArray, errorMessages, innerHTMLAssetNames, templatePath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, cmn.ConfigurationFile.read(path.join(options.source, "game.json"), options.logger)];
                case 1:
                    content = _a.sent();
                    if (!content.environment)
                        content.environment = {};
                    content.environment["sandbox-runtime"] = content.environment["sandbox-runtime"] ? content.environment["sandbox-runtime"] : "1";
                    conf = new cmn.Configuration({
                        content: content
                    });
                    innerHTMLAssetArray = [];
                    innerHTMLAssetArray.push({
                        name: "game.json",
                        type: "text",
                        code: convertUtil_1.encodeText(JSON.stringify(conf._content, null, "\t"))
                    });
                    errorMessages = [];
                    innerHTMLAssetNames = convertUtil_1.extractAssetDefinitions(conf, "script");
                    if (!options.unbundleText) {
                        innerHTMLAssetNames = innerHTMLAssetNames.concat(convertUtil_1.extractAssetDefinitions(conf, "text"));
                    }
                    innerHTMLAssetArray = innerHTMLAssetArray.concat(innerHTMLAssetNames.map(function (assetName) {
                        return convertAssetToInnerHTMLObj(assetName, options.source, conf, options.minify, options.lint, errorMessages);
                    }));
                    if (conf._content.globalScripts) {
                        innerHTMLAssetArray = innerHTMLAssetArray.concat(conf._content.globalScripts.map(function (scriptName) {
                            return convertScriptNameToInnerHTMLObj(scriptName, options.source, options.minify, options.lint, errorMessages);
                        }));
                    }
                    if (errorMessages.length > 0) {
                        options.logger.warn("The following ES5 syntax errors exist.\n" + errorMessages.join("\n"));
                    }
                    switch (conf._content.environment["sandbox-runtime"]) {
                        case "1":
                            templatePath = "templates-build/v1";
                            break;
                        case "2":
                            templatePath = "templates-build/v2";
                            break;
                        default:
                            throw Error("Unknown engine version: `environment[\"sandbox-runtime\"]` field in game.json should be \"1\" or \"2\".");
                    }
                    writeEct(innerHTMLAssetArray, options.output, conf, options, templatePath);
                    writeCommonFiles(options.source, options.output, conf, options, templatePath);
                    return [2 /*return*/];
            }
        });
    });
}
exports.promiseConvertBundle = promiseConvertBundle;
function convertAssetToInnerHTMLObj(assetName, inputPath, conf, minify, lint, errors) {
    var assets = conf._content.assets;
    var isScript = assets[assetName].type === "script";
    var assetString = fs.readFileSync(path.join(inputPath, assets[assetName].path), "utf8").replace(/\r\n|\r/g, "\n");
    if (isScript && lint) {
        errors.push.apply(errors, convertUtil_1.validateEs5Code(assets[assetName].path, assetString));
    }
    return {
        name: assetName,
        type: assets[assetName].type,
        code: isScript ? convertUtil_1.wrap(assetString, minify) : convertUtil_1.encodeText(assetString)
    };
}
function convertScriptNameToInnerHTMLObj(scriptName, inputPath, minify, lint, errors) {
    var scriptString = fs.readFileSync(path.join(inputPath, scriptName), "utf8").replace(/\r\n|\r/g, "\n");
    var isScript = /\.js$/i.test(scriptName);
    var scriptPath = path.resolve("./", scriptName);
    if (path.extname(scriptPath) === ".json") {
        scriptString = convertUtil_1.encodeText(scriptString);
    }
    if (isScript && lint) {
        errors.push.apply(errors, convertUtil_1.validateEs5Code(scriptName, scriptString));
    }
    return {
        name: scriptName,
        type: isScript ? "script" : "text",
        code: isScript ? convertUtil_1.wrap(scriptString, minify) : scriptString
    };
}
function writeEct(innerHTMLAssetArray, outputPath, conf, options, templatePath) {
    var injects = options.injects ? options.injects : [];
    var scripts = convertUtil_1.getDefaultBundleScripts(templatePath, options.minify, !options.unbundleText);
    var ectRender = ect({ root: __dirname + "/../templates-build", ext: ".ect" });
    var html = ectRender.render("bundle-index", {
        assets: innerHTMLAssetArray,
        preloadScripts: scripts.preloadScripts,
        postloadScripts: scripts.postloadScripts,
        css: convertUtil_1.getDefaultBundleStyle(templatePath),
        magnify: !!options.magnify,
        injectedContents: convertUtil_1.getInjectedContents(options.cwd, injects)
    });
    fs.writeFileSync(path.resolve(outputPath, "./index.html"), html);
}
function writeCommonFiles(inputPath, outputPath, conf, options, templatePath) {
    if (options.strip) {
        convertUtil_1.copyAssetFilesStrip(inputPath, outputPath, conf._content.assets, options);
    }
    else {
        convertUtil_1.copyAssetFiles(inputPath, outputPath, options);
    }
    var jsDir = path.resolve(outputPath, "js");
    var cssDir = path.resolve(outputPath, "css");
    fsx.copySync(path.resolve(__dirname, "..", templatePath), outputPath, { filter: function (src, dest) { return (dest !== jsDir && dest !== cssDir); } });
}
